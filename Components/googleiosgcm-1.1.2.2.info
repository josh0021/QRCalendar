{"Name":"Google Cloud Messaging for iOS","Id":2679,"Alias":"googleiosgcm","Description":"Send data from your server to your users\u0027 devices, and receive messages from devices on the same connection. The GCM service handles all aspects of queueing of messages and delivery to client applications running on target devices, and it is completely free.\n\n### Versatile Messaging Targets\n\nDistribute messages to your client app in any of three ways — to single devices, to groups of devices, or to devices subscribed to topics.\n\n### Downstream Messaging\n\nFor purposes such as alerting users, chat messaging or kicking off background processing before the user opens the client app, GCM provides a reliable and battery-efficient connection between your server and devices.\n\n### Upstream Messaging\n\nSend acknowledgments, chats, and other messages from devices back to your server over GCM’s reliable and battery-efficient connection channel.\n\n","Version":"1.1.2.2","Summary":"Simple and reliable messaging to reach over a billion devices.","QuickStart":"Configuring APNS\n----------------\n\nTo allow Google to send APNS notifications on your behalf, you will need to export your Developer and/or your Production APNS certificates from the Apple Developer portal as .p12 files.\n\nFor more information on this process, see [Apple\u0027s Documentation][2].\n\n\n\nConfiguring your App\n--------------------\n\nGoogle provides an easy to use configuration web tool to generate a config file for your app:  \n\n1. Open [Google\u0027s configuration tool][1] to create a config file for your app.\n2. Enter your app\u0027s name and iOS Bundle ID and click continue\n3. Upload your Developer APNS .p12 certificate.  You may also want to upload your production .p12 certificate at this time as well.\n3. Click *Enable Cloud Messaging*\n4. Click *continue* to generate the configuration files\n5. Click *Download Google-Service-Info.plist*\n6. Add `GoogleService-Info.plist` to your Xamarin.iOS app project and set the *Build Action* to `BundleResource`\n7. Note the *Sender ID* value.  You will use this in your code as the `GCM_SENDER_ID` value.\n\n\n\nSetting up your AppDelegate\n---------------------------\n\nYour `AppDelegate` will contain most of the GCM related code.\n\nIn your `FinishedLaunching` method you should start GCM and request to register for remote notifications:\n\n```csharp\npublic override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions)\n{                   \n    // Configure and Start GCM\n\tvar gcmConfig = Google.GoogleCloudMessaging.Config.DefaultConfig;\n\tgcmConfig.ReceiverDelegate = this;\n\tService.SharedInstance.Start (gcmConfig);\n    \n\t// Register for remote notifications\n\tvar notTypes = UIUserNotificationType.Sound | UIUserNotificationType.Alert | UIUserNotificationType.Badge;\n\tvar settings = UIUserNotificationSettings.GetSettingsForTypes (notTypes, null);\n\tUIApplication.SharedApplication.RegisterUserNotificationSettings (settings);\n\tUIApplication.SharedApplication.RegisterForRemoteNotifications ();\n\n\t// Your user code, if any, here\n\n\treturn true;\n}\n```\n\nSince in the code above the GCM Config\u0027s delegate was set to `this` (the AppDelegate), you should also implement `IReceiverDelegate` in your `AppDelegate` class:\n\nNext, add an override for handling the registration for remote notifications:\n\n```csharp\npublic override void RegisteredForRemoteNotifications (UIApplication application, NSData deviceToken)\n{          \n\t// Save our token in memory for future calls to GCM\n\tDeviceToken = deviceToken;\n\n\t// Configure and start Instance ID\n\tvar config = Google.InstanceID.Config.DefaultConfig;\n\tInstanceId.SharedInstance.Start (config);\n\n\t// Get a GCM token\n\tGetToken ();\n}\n```\n\nIn this method, you will save the `deviceToken` to a variable for later use, as well as configure and start InstanceID which is needed to obtain a GCM Registration Token.\n\nFinally, this method calls `GetToken()` to actually request a GCM Registration token, which is defined as:\n\n```csharp\nvoid GetToken ()\n{\n\t// Register APNS Token to GCM\n\tvar options = new NSDictionary ();\n\toptions.SetValueForKey (DeviceToken, Constants.RegisterAPNSOption);\n\toptions.SetValueForKey (new NSNumber(true), Constants.APNSServerTypeSandboxOption);\n\n\t// Get our token\n\tInstanceId.SharedInstance.Token (\n\t\tGCM_SENDER_ID,\n\t\tConstants.ScopeGCM,\n\t\toptions,\n\t\t(token, error) =\u003e Log (\"GCM Registration ID: \" + token));\n}\n```\n\nIf the `error` value is null in the callback that was passed into the `Token()` method, you should have a valid GCM Registration token which you will then use on your server to send messages to this device.\n\n\n### Receiving Notifications\n\nNotifications (both APNS and from GCM) will occur inside of the `DidReceiveRemoteNotification` override.  When you receive a message you should inform GCM that you successfully received it:\n\n```csharp\npublic override void DidReceiveRemoteNotification (UIApplication application, NSDictionary userInfo, Action\u003cUIBackgroundFetchResult\u003e completionHandler)\n{\n\t// Your own notification handling logic here\n\t\n\t// Notify GCM we received the message\n\tService.SharedInstance.AppDidReceiveMessage (userInfo);\n}\n```\n\n\n\n### Connecting to GCM Servers Directly\n\nWhen your application is in the foreground you should connect directly to GCM\u0027s servers:\n\n```csharp\npublic override void OnActivated (UIApplication application)\n{\n\tService.SharedInstance.Connect (error =\u003e {\n\t\tif (error != null)\n\t\t\tConsole.WriteLine (\"Could not connect to GCM: {0}\", error.LocalizedDescription);\n\t\telse\n\t\t\tConsole.WriteLine (\"Connected to GCM\");\n\t});\n}\n```\n\nIt\u0027s also important to disconnect from the GCM Server when your application enters the background so you can continue to receive APNS notifications instead:\n\n```csharp\npublic override void DidEnterBackground (UIApplication application)\n{\n\tService.SharedInstance.Disconnect ();\n}\n```\n\n\n### Unregistering from GCM\n\nIt\u0027s possible to unregister from GCM by deleting your token:\n\n```csharp\npublic void DeleteToken ()\n{\n\tInstanceId.SharedInstance.DeleteToken (\n\tGCM_SENDER_ID,\n\tConstants.ScopeGCM,\n\terror =\u003e {\n\t\t// Callback, non-null error if there was a problem\n\t\tif (error != null)\n\t\t\tConsole.WriteLine (\"Deleted Token\");\n\t\telse \n\t\t\tConsole.WriteLine (\"Error deleting token\");\n\t});\n}\n```\n\n### Sending Upstream Messages\n\nOne of the advantages to being directly connected to GCM\u0027s Servers when your app is in the foreground is the ability to send upstream messages back to the server:\n\n```csharp\nint messageId = 1;\n\n// We can send upstream messages back to GCM\npublic void SendUpstreamMessage ()\n{            \n    var msg = new NSDictionary ();\n    msg.SetValueForKey (new NSString (\"1234\"), new NSString (\"userId\"));\n    msg.SetValueForKey (new NSString (\"hello world\"), new NSString (\"msg\"));\n\n    var to = GCM_SENDER_ID + \"@gcm.googleapis.com\";\n\n    Service.SharedInstance.SendMessage (msg, to, (messageId++).ToString ());\n}\n```\n\n### Handling Callbacks for Upstream Messages\n\nSince you implemented `IReceiverDelegate` in your AppDelegate, you can add some methods to be invoked as callbacks for upstream messages:\n\n```csharp\n[Export (\"didDeleteMessagesOnServer\")]\npublic void DidDeleteMessagesOnServer ()\n{\n\t// ...\n}\n\n[Export (\"didSendDataMessageWithID:\")]\npublic void DidSendDataMessage (string messageID)\n{\n\t// ...\n}\n\n[Export (\"willSendDataMessageWithID:error:\")]\npublic void WillSendDataMessage (string messageID, NSError error)\n{\n\t// ...\n}\n```\n\n\n[1]: https://developers.google.com/mobile/add?platform=ios\u0026cntapi=signin\n[2]: https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/ConfiguringPushNotifications/ConfiguringPushNotifications.html","Hash":"c25e1b4c0186556e6e99d20bcb6085f8","TargetPlatforms":["ios"],"TrialHash":null}